#+PROPERTY: header-args :session *my_session*
#+PROPERTY: header-args+ :results silent
#+PROPERTY: header-args+ :tangle yes

* Editing configurations

These settings involve how text is changed in Emacs.

** Changing text properties

 Custom toggle comment keybinding.
 #+BEGIN_SRC emacs-lisp
   (global-set-key (kbd "s-c") 'comment-line)
 #+END_SRC

** Killing

 Emacs default behaviour when deleting a word is to copy it to kill-ring.
 Better avoid this, delegating the killing to ~C-w~.
 #+BEGIN_SRC emacs-lisp
   (global-set-key (kbd "<C-backspace>") 'delete-word)
   (global-set-key (kbd "<C-delete>")    'delete-word)
   (global-set-key (kbd "M-DEL")         'delete-word)

   (defun delete-word (arg)
     "Delete characters backward until encountering the beginning of a word.
      With argument ARG, do this that many times."
     (interactive "p")
     (delete-region (point) (progn (backward-word arg) (point))))
 #+END_SRC

 If no region is selected, ~C-w~ kills whole line.
 #+BEGIN_SRC emacs-lisp
   (global-set-key (kbd "C-w") 'kill-line-or-region)

   (defun kill-line-or-region ()
     "Kill region if active only or kill line (smartly)"
     (interactive)
     (if (region-active-p)
         (call-interactively 'kill-region)
       (call-interactively 'smart-kill-whole-line)))

   (defun smart-kill-whole-line (&optional arg)
     "A simple wrapper around `kill-whole-line' that respects indentation."
     (interactive "P")
     (kill-whole-line arg)
     (back-to-indentation))
 #+END_SRC

** Copying

 If no region is selected, ~M-w~ copies whole line.
 #+BEGIN_SRC emacs-lisp
   (global-set-key (kbd "M-w") 'copy-line-or-region)

   (defun copy-line (arg)
     "Copy lines (as many as prefix argument) in the kill ring.
         Ease of use features:
         - Move to start of next line.
         - Appends the copy on sequential calls.
         - Use newline as last char even on the last line of the buffer.
         - If region is active, copy its lines."
     (interactive "p")
     (let ((beg (line-beginning-position))
           (end (line-end-position arg)))
       (when mark-active
         (if (> (point) (mark))
             (setq beg (save-excursion
                         (goto-char (mark))
                         (line-beginning-position)))
           (setq end (save-excursion
                       (goto-char (mark))
                       (line-end-position)))))
       (if (eq last-command 'copy-line)
           (kill-append (buffer-substring beg end) (< end beg))
         (kill-ring-save beg end)))
     (kill-append "\n" nil)
     (beginning-of-line (or (and arg (1+ arg)) 2))
     (if (and arg (not (= 1 arg))) (message "%d lines copied" arg)))

   (defun copy-line-or-region ()
     "Copy region if active only or copy whole line"
     (interactive)
     (if (region-active-p)
         (call-interactively 'kill-ring-save)
       (call-interactively 'copy-line)))
 #+END_SRC

 Copy current file path in kill-ring.
 #+BEGIN_SRC emacs-lisp
  (global-set-key [C-f1] 'kill-file-name)

  (defun kill-file-name ()

  "Get file name as last element in kill ring, i.e. copy file name to clipboard."
    (interactive)
    (let ((file-name (buffer-file-name)))
      (if file-name
          (progn
            (message (concat "\"" file-name "\" copied to clipboard"))
            (kill-new file-name))
            (message "Current buffer is not related to any file"))))
 #+END_SRC
